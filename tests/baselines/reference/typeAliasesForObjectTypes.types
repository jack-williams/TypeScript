=== tests/cases/conformance/types/typeAliases/typeAliasesForObjectTypes.ts ===
type T1 = { x: string }
>T1 : T1
>x : string

// An interface can be named in an extends or implements clause, but a type alias for an object type literal cannot.
interface I1 extends T1 { y: string }
>y : string

class C1 implements T1 {
>C1 : C1

    x: string;
>x : string
}

// An interface can have multiple merged declarations, but a type alias for an object type literal cannot.
type T2 = { x: string }
>T2 : T2
>x : string

type T2 = { y: number }
>T2 : { y: number; }
>y : number

// An interface can have type parameters, but a type alias for an object type literal cannot.
type T3<T> = { x: T }
>T3 : T3<T>
>x : T


// Repro from #29991

const a: Required<{ a?: 1; x: 1 }> = { a: 1, x: 1 };
>a : Required<{ a?: 1; x: 1; }>
>a : 1
>x : 1
>{ a: 1, x: 1 } : { a: 1; x: 1; }
>a : 1
>1 : 1
>x : 1
>1 : 1

const b: Required<{ b?: 1; x: 1 }> = { b: 1, x: 1 };
>b : Required<{ b?: 1; x: 1; }>
>b : 1
>x : 1
>{ b: 1, x: 1 } : { b: 1; x: 1; }
>b : 1
>1 : 1
>x : 1
>1 : 1

export let A = a;
>A : Required<{ a?: 1; x: 1; }>
>a : Required<{ a?: 1; x: 1; }>

export let B = b;
>B : Required<{ b?: 1; x: 1; }>
>b : Required<{ b?: 1; x: 1; }>

A = b; // No Error
>A = b : Required<{ b?: 1; x: 1; }>
>A : Required<{ a?: 1; x: 1; }>
>b : Required<{ b?: 1; x: 1; }>

B = a; // No Error
>B = a : Required<{ a?: 1; x: 1; }>
>B : Required<{ b?: 1; x: 1; }>
>a : Required<{ a?: 1; x: 1; }>

a.b; // Property 'b' does not exist on type 'Required<{ a?: 1; x: 1; }>'.
>a.b : any
>a : Required<{ a?: 1; x: 1; }>
>b : any

b.a; // Property 'a' does not exist on type 'Required<{ b?: 1; x: 1; }>'.
>b.a : any
>b : Required<{ b?: 1; x: 1; }>
>a : any

